{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar utils = require('./utils');\n\nvar getTransactionSignature = utils.getTransactionSignature;\nvar getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nvar parseHexString = utils.parseHexString;\nvar removeHexPrefix = utils.removeHexPrefix;\nvar padTo64 = utils.padTo64;\n\nvar ServerHelper = require('./ServerHelper');\n\nvar HttpWrapper = require('./HttpWrapper');\n\nvar ethUtils = require('ethereumjs-util');\n\nvar ethWallet = require('ethereumjs-wallet');\n\nvar ethJsTx = require('ethereumjs-tx');\n\nvar abi_decoder = require('abi-decoder');\n\nvar relayHubAbi = require('./IRelayHub'); // This file is only needed so we don't change IRelayHub code, which would affect RelayHub expected deployed address\n// TODO: Once we change RelayHub version, we should add abstract method \"function version() external returns (string memory);\" to IRelayHub.sol and remove IRelayHubVersionAbi.json\n\n\nvar versionAbi = require('./IRelayHubVersionAbi');\n\nrelayHubAbi.push(versionAbi);\n\nvar relayRecipientAbi = require('./IRelayRecipient');\n\nvar relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi); // default timeout (in ms) for http requests\n\nvar DEFAULT_HTTP_TIMEOUT = 10000; //default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\n\nvar GASPRICE_PERCENT = 20;\nvar canRelayStatus = {\n  1: \"1 WrongSignature\",\n  // The transaction to relay is not signed by requested sender\n  2: \"2 WrongNonce\",\n  // The provided nonce has already been used by the sender\n  3: \"3 AcceptRelayedCallReverted\",\n  // The recipient rejected this call via acceptRelayedCall\n  4: \"4 InvalidRecipientStatusCode\" // The recipient returned an invalid (reserved) status code\n\n};\n\nvar RelayClient =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *    validateCanRelay - client calls canRelay before calling the relay the first time (defaults to true)\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    relayUrl, relayAddress - avoid lookup on relayHub for relays, and always use this URL/address\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  function RelayClient(web3, config) {\n    _classCallCheck(this, RelayClient);\n\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign({\n      validateCanRelay: true,\n      httpTimeout: DEFAULT_HTTP_TIMEOUT\n    }, config);\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({\n      timeout: this.config.httpTimeout\n    });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  _createClass(RelayClient, [{\n    key: \"createRelayRecipient\",\n    value: function createRelayRecipient(addr) {\n      return new this.web3.eth.Contract(relayRecipientAbi, addr);\n    }\n  }, {\n    key: \"createRelayHub\",\n    value: function createRelayHub(addr) {\n      return new this.web3.eth.Contract(relayHubAbi, addr);\n    }\n    /**\n     * Decode the signed transaction returned from the Relay Server, compare it to the\n     * requested transaction and validate its signature.\n     * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n     * transaction is not valid.\n     */\n\n  }, {\n    key: \"validateRelayResponse\",\n    value: function validateRelayResponse(returned_tx, address_relay, from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address, sig, approvalData) {\n      var tx = new ethJsTx({\n        nonce: returned_tx.nonce,\n        gasPrice: returned_tx.gasPrice,\n        gasLimit: returned_tx.gas,\n        to: returned_tx.to,\n        value: returned_tx.value,\n        data: returned_tx.input\n      });\n      var message = tx.hash(false);\n      var tx_v = Buffer.from(removeHexPrefix(returned_tx.v), \"hex\");\n      var tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), \"hex\");\n      var tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), \"hex\");\n      var signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n      var request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n      var returned_tx_params_hash = utils.getTransactionHash(request_decoded_params[0].value, request_decoded_params[1].value, request_decoded_params[2].value, request_decoded_params[3].value, request_decoded_params[4].value, request_decoded_params[5].value, request_decoded_params[6].value, returned_tx.to, signer);\n      var transaction_orig_params_hash = utils.getTransactionHash(from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address);\n\n      if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n        if (this.config.verbose) {\n          console.log(\"validateRelayResponse - valid transaction response\");\n        }\n\n        tx.v = tx_v;\n        tx.r = tx_r;\n        tx.s = tx_s;\n        return tx;\n      } else {\n        console.error(\"validateRelayResponse: req\", JSON.stringify(request_decoded_params));\n        console.error(\"validateRelayResponse: rsp\", {\n          returned_tx: returned_tx,\n          address_relay: address_relay,\n          from: from,\n          to: to,\n          transaction_orig: transaction_orig,\n          transaction_fee: transaction_fee,\n          gas_price: gas_price,\n          gas_limit: gas_limit,\n          nonce: nonce,\n          sig: sig,\n          approvalData: approvalData,\n          signer: signer\n        });\n      }\n    }\n    /**\n     * Performs a '/relay' HTTP request to the given url\n     * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n     */\n\n  }, {\n    key: \"sendViaRelay\",\n    value: function sendViaRelay(relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, signature, approvalData, relayUrl, relayHubAddress, relayMaxNonce) {\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        var jsonRequestData = {\n          \"encodedFunction\": encodedFunction,\n          \"signature\": parseHexString(signature.replace(/^0x/, '')),\n          \"approvalData\": parseHexString(approvalData.replace(/^0x/, '')),\n          \"from\": from,\n          \"to\": to,\n          \"gasPrice\": gasprice,\n          \"gasLimit\": gaslimit,\n          \"relayFee\": relayFee,\n          \"RecipientNonce\": parseInt(recipientNonce),\n          \"RelayMaxNonce\": parseInt(relayMaxNonce),\n          \"RelayHubAddress\": relayHubAddress\n        };\n\n        var callback =\n        /*#__PURE__*/\n        function () {\n          var _ref = _asyncToGenerator(\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee(error, body) {\n            var validTransaction, receivedNonce, raw_tx, txHash;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (!error) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    if (error.error && error.error.indexOf(\"timeout\") != -1) {\n                      self.failedRelays[relayUrl] = {\n                        lastError: new Date().getTime(),\n                        address: relayAddress,\n                        url: relayUrl\n                      };\n                    }\n\n                    reject(error);\n                    return _context.abrupt(\"return\");\n\n                  case 4:\n                    if (self.config.verbose) {\n                      console.log(\"sendViaRelay resp=\", body);\n                    }\n\n                    if (!(body && body.error)) {\n                      _context.next = 8;\n                      break;\n                    }\n\n                    reject(body.error);\n                    return _context.abrupt(\"return\");\n\n                  case 8:\n                    if (!(!body || !body.nonce)) {\n                      _context.next = 11;\n                      break;\n                    }\n\n                    reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n                    return _context.abrupt(\"return\");\n\n                  case 11:\n                    try {\n                      validTransaction = self.validateRelayResponse(body, relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, relayHubAddress, relayAddress, signature, approvalData);\n                    } catch (error) {\n                      console.error(\"validateRelayResponse \" + error);\n                    }\n\n                    if (validTransaction) {\n                      _context.next = 15;\n                      break;\n                    }\n\n                    reject(\"Failed to validate response\");\n                    return _context.abrupt(\"return\");\n\n                  case 15:\n                    receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n\n                    if (!(receivedNonce > relayMaxNonce)) {\n                      _context.next = 19;\n                      break;\n                    }\n\n                    // TODO: need to validate that client retries the same request and doesn't double-spend.\n                    // Note that this transaction is totally valid from the EVM's point of view\n                    reject(\"Relay used a tx nonce higher than requested. Requested \" + relayMaxNonce + \" got \" + receivedNonce);\n                    return _context.abrupt(\"return\");\n\n                  case 19:\n                    raw_tx = '0x' + validTransaction.serialize().toString('hex');\n                    txHash = \"0x\" + validTransaction.hash(true).toString('hex');\n                    console.log(\"txHash= \" + txHash);\n                    self.broadcastRawTx(raw_tx, txHash);\n                    resolve(validTransaction);\n\n                  case 24:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n          return function callback(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        if (self.config.verbose) {\n          var replacer = function replacer(key, value) {\n            if (key === \"signature\") return signature;else return value;\n          };\n\n          console.log(\"sendViaRelay to URL: \" + relayUrl + \" \" + JSON.stringify(jsonRequestData, replacer));\n        }\n\n        self.httpSend.send(relayUrl + \"/relay\", jsonRequestData, callback);\n      });\n    }\n    /**\n     * In case Relay Server does not broadcast the signed transaction to the network,\n     * client also broadcasts the same transaction. If the transaction fails with nonce\n     * error, it indicates Relay may have signed multiple transactions with same nonce,\n     * causing a DoS attack.\n     *\n     * @param {*} raw_tx - raw transaction bytes, signed by relay\n     * @param {*} tx_hash - this transaction's ID\n     */\n\n  }, {\n    key: \"broadcastRawTx\",\n    value: function broadcastRawTx(raw_tx, tx_hash) {\n      var self = this;\n      self.web3.eth.sendSignedTransaction(raw_tx, function (error, result) {\n        //TODO: at this point both client and relay has sent the transaction to the blockchain.\n        // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n        // to penalize original relay for cheating: returning one transaction to the client, and\n        // broadcasting another with the same nonce.\n        // see the EIP for description of the attack\n        //don't display error for the known-good cases\n        if (!(\"\" + error).match(/the tx doesn't have the correct nonce|known transaction/)) console.log(\"broadcastTx: \", error || result);\n\n        if (error) {//note that nonce-related errors at this point are VALID reponses: it means that\n          // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n          // the only point is that different node versions return different error strings:\n          // ganache:  \"the tx doesn't have the correct nonce\"\n          // ropsten: \"known transaction\"\n        } else {\n          if (result == tx_hash) {//transaction already on chain\n          }\n        }\n      });\n    }\n    /**\n     * check the balance of the given target contract.\n     * the method will fail if the target is not a RelayRecipient.\n     * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n     */\n\n  }, {\n    key: \"balanceOf\",\n    value: function () {\n      var _balanceOf = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(target) {\n        var relayHub;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.createRelayHubFromRecipient(target);\n\n              case 2:\n                relayHub = _context2.sent;\n                return _context2.abrupt(\"return\", relayHub.methods.balanceOf(target).call());\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function balanceOf(_x3) {\n        return _balanceOf.apply(this, arguments);\n      }\n\n      return balanceOf;\n    }()\n    /**\n     * Options include standard transaction params: from,to, gas_price, gas_limit\n     * relay-specific params:\n     *  txfee (override config.txfee)\n     *  validateCanRelay - client calls canRelay before calling the relay the first time (defaults to true)\n     * can also override default relayUrl, relayFee\n     * return value is the same as from sendTransaction\n     */\n\n  }, {\n    key: \"relayTransaction\",\n    value: function () {\n      var _relayTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(encodedFunctionCall, options) {\n        var self, relayHub, nonce, pct, network_gas_price, gasPrice, gasLimit, blockNow, blockFrom, pinger, errors, firstTry, activeRelay, error, relayAddress, relayUrl, txfee, hash, signature, approvalData, rec, allowed_relay_nonce_gap, relayMaxNonce, res, errorMsg, status, validTransaction;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                //validateCanRelay defaults (in config). to disable, explicitly set options.validateCanRelay=false\n                options = Object.assign({\n                  validateCanRelay: this.config.validateCanRelay\n                }, options);\n                self = this;\n                _context3.next = 4;\n                return this.createRelayHubFromRecipient(options.to);\n\n              case 4:\n                relayHub = _context3.sent;\n                _context3.t0 = parseInt;\n                _context3.next = 8;\n                return relayHub.methods.getNonce(options.from).call();\n\n              case 8:\n                _context3.t1 = _context3.sent;\n                nonce = (0, _context3.t0)(_context3.t1);\n                this.serverHelper.setHub(relayHub); //gas-price multiplicator: either default (10%) or configuration factor\n\n                pct = this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n                _context3.next = 14;\n                return this.web3.eth.getGasPrice();\n\n              case 14:\n                network_gas_price = _context3.sent;\n\n                // Sometimes, xDai netwiork returns '0'\n                if (!network_gas_price || network_gas_price == 0) {\n                  network_gas_price = 1e9;\n                }\n\n                gasPrice = this.config.force_gasPrice || //forced gasprice\n                options.gas_price || //user-supplied gas price\n                Math.round(network_gas_price * (pct + 100) / 100); //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n\n                gasLimit = this.config.force_gasLimit || options.gas_limit;\n                _context3.next = 20;\n                return this.web3.eth.getBlockNumber();\n\n              case 20:\n                blockNow = _context3.sent;\n                blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n                _context3.next = 24;\n                return this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n\n              case 24:\n                pinger = _context3.sent;\n                errors = [];\n                firstTry = true;\n\n              case 27:\n                _context3.next = 29;\n                return pinger.nextRelay();\n\n              case 29:\n                activeRelay = _context3.sent;\n\n                if (activeRelay) {\n                  _context3.next = 34;\n                  break;\n                }\n\n                error = new Error(\"No relay responded! \" + pinger.relaysCount + \" attempted, \" + pinger.pingedRelays + \" pinged\");\n                error.otherErrors = errors;\n                throw error;\n\n              case 34:\n                relayAddress = activeRelay.RelayServerAddress;\n                relayUrl = activeRelay.relayUrl;\n                txfee = parseInt(options.txfee || activeRelay.transactionFee);\n                hash = utils.getTransactionHash(options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, relayHub._address, relayAddress);\n                signature = void 0;\n\n                if (!(typeof self.ephemeralKeypair === \"object\" && self.ephemeralKeypair !== null)) {\n                  _context3.next = 45;\n                  break;\n                }\n\n                _context3.next = 42;\n                return getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n\n              case 42:\n                signature = _context3.sent;\n                _context3.next = 48;\n                break;\n\n              case 45:\n                _context3.next = 47;\n                return getTransactionSignature(this.web3, options.from, hash);\n\n              case 47:\n                signature = _context3.sent;\n\n              case 48:\n                approvalData = \"0x\";\n\n                if (!(typeof options.approveFunction === \"function\")) {\n                  _context3.next = 54;\n                  break;\n                }\n\n                _context3.next = 52;\n                return options.approveFunction({\n                  from: options.from,\n                  to: options.to,\n                  encodedFunctionCall: encodedFunctionCall,\n                  txfee: options.txfee,\n                  gas_price: gasPrice,\n                  gas_limit: gasLimit,\n                  nonce: nonce,\n                  relay_hub_address: relayHub._address,\n                  relay_address: relayAddress\n                });\n\n              case 52:\n                _context3.t2 = _context3.sent;\n                approvalData = \"0x\" + _context3.t2;\n\n              case 54:\n                if (self.config.verbose) {\n                  console.log(\"relayTransaction hash: \", hash, \"from: \", options.from, \"sig: \", signature);\n                  rec = utils.getEcRecoverMeta(hash, signature);\n\n                  if (rec.toLowerCase() === options.from.toLowerCase()) {\n                    console.log(\"relayTransaction recovered:\", rec, \"signature is correct\");\n                  } else {\n                    console.error(\"relayTransaction recovered:\", rec, \"signature error\");\n                  }\n                } // max nonce is not signed, as contracts cannot access addresses' nonces.\n\n\n                allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap;\n\n                if (typeof allowed_relay_nonce_gap === \"undefined\") {\n                  allowed_relay_nonce_gap = 3;\n                }\n\n                _context3.next = 59;\n                return this.web3.eth.getTransactionCount(relayAddress);\n\n              case 59:\n                _context3.t3 = _context3.sent;\n                _context3.t4 = allowed_relay_nonce_gap;\n                relayMaxNonce = _context3.t3 + _context3.t4;\n\n                if (!(options.validateCanRelay && firstTry)) {\n                  _context3.next = 71;\n                  break;\n                }\n\n                firstTry = false;\n                _context3.next = 66;\n                return relayHub.methods.canRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData).call();\n\n              case 66:\n                res = _context3.sent;\n\n                if (!(res.status != 0)) {\n                  _context3.next = 71;\n                  break;\n                }\n\n                //in case of error, the context is an error message.\n                errorMsg = res.recipientContext ? Buffer.from(res.recipientContext.slice(2), 'hex').toString() : \"\";\n                status = canRelayStatus[res.status] || res.status;\n                throw new Error(\"canRelay failed: \" + status + \": \" + errorMsg);\n\n              case 71:\n                _context3.prev = 71;\n                _context3.next = 74;\n                return self.sendViaRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData, relayUrl, relayHub._address, relayMaxNonce);\n\n              case 74:\n                validTransaction = _context3.sent;\n                return _context3.abrupt(\"return\", validTransaction);\n\n              case 78:\n                _context3.prev = 78;\n                _context3.t5 = _context3[\"catch\"](71);\n                errors.push(_context3.t5);\n\n                if (self.config.verbose) {\n                  console.log(\"relayTransaction: req:\", {\n                    from: options.from,\n                    to: options.to,\n                    encodedFunctionCall: encodedFunctionCall,\n                    txfee: options.txfee,\n                    gasPrice: gasPrice,\n                    gasLimit: gasLimit,\n                    nonce: nonce,\n                    relayhub: relayHub._address,\n                    relayAddress: relayAddress\n                  });\n                  console.log(\"relayTransaction:\", (\"\" + _context3.t5).replace(/ (\\w+:)/g, \"\\n$1 \"));\n                }\n\n              case 82:\n                _context3.next = 27;\n                break;\n\n              case 84:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[71, 78]]);\n      }));\n\n      function relayTransaction(_x4, _x5) {\n        return _relayTransaction.apply(this, arguments);\n      }\n\n      return relayTransaction;\n    }()\n  }, {\n    key: \"fixTransactionReceiptResp\",\n    value: function fixTransactionReceiptResp(respResult) {\n      if (respResult && respResult.logs) {\n        var logs = abi_decoder.decodeLogs(respResult.logs);\n        var canRelayFailed = logs.find(function (e) {\n          return e && e.name == 'CanRelayFailed';\n        });\n        var transactionRelayed = logs.find(function (e) {\n          return e && e.name == 'TransactionRelayed';\n        });\n\n        var setErrorStatus = function setErrorStatus(reason) {\n          console.log(\"\".concat(reason, \". changing status to zero\"));\n          respResult.status = 0;\n        };\n\n        if (canRelayFailed) {\n          setErrorStatus(\"canRelay failed: \".concat(canRelayFailed.events.find(function (e) {\n            return e.name == \"reason\";\n          }).value));\n        } else if (transactionRelayed) {\n          var status = transactionRelayed.events.find(function (e) {\n            return e.name == \"status\";\n          }).value;\n\n          if (status != 0) {\n            // 0 signifies success\n            setErrorStatus(\"reverted relayed transaction, status code \".concat(status));\n          }\n        }\n      }\n    }\n  }, {\n    key: \"runRelay\",\n    value: function runRelay(payload, callback) {\n      var params = payload.params[0];\n      var relayClientOptions = this.config;\n      var relayOptions = {\n        from: params.from,\n        to: params.to,\n        txfee: params.txFee || params.txfee || relayClientOptions.txfee,\n        gas_limit: params.gas && parseInt(params.gas, 16),\n        gas_price: params.gasPrice && parseInt(params.gasPrice, 16)\n      };\n      if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n      this.relayTransaction(params.data, relayOptions).then(function (validTransaction) {\n        var hash = \"0x\" + validTransaction.hash(true).toString('hex');\n        callback(null, {\n          jsonrpc: '2.0',\n          id: payload.id,\n          result: hash\n        });\n      }).catch(function (err) {\n        if (relayClientOptions.verbose) console.log(\"RR error: \", err);\n        callback(err, null);\n      });\n    }\n  }, {\n    key: \"postAuditTransaction\",\n    value: function postAuditTransaction(signedTx, relayUrl) {\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        var callback = function callback(error, response) {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(response);\n        };\n\n        self.httpSend.send(relayUrl + \"/audit\", {\n          signedTx: signedTx\n        }, callback);\n      });\n    }\n    /**\n     * Send a transaction signed by a relay to other relays for audit.\n     * This is done in order to prevent nonce reuse by a misbehaving relay.\n     *\n     * @param {*} transaction\n     * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n     */\n\n  }, {\n    key: \"auditTransaction\",\n    value: function () {\n      var _auditTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(transaction, auditingRelays) {\n        var relay;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.t0 = _regeneratorRuntime.keys(auditingRelays);\n\n              case 1:\n                if ((_context4.t1 = _context4.t0()).done) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                relay = _context4.t1.value;\n                _context4.next = 5;\n                return this.postAuditTransaction(transaction, auditingRelays[relay]);\n\n              case 5:\n                _context4.next = 1;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function auditTransaction(_x6, _x7) {\n        return _auditTransaction.apply(this, arguments);\n      }\n\n      return auditTransaction;\n    }()\n  }, {\n    key: \"useKeypairForSigning\",\n    value: function useKeypairForSigning(ephemeralKeypair) {\n      if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n        ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), \"hex\");\n      }\n\n      this.ephemeralKeypair = ephemeralKeypair;\n    }\n  }, {\n    key: \"createRelayHubFromRecipient\",\n    value: function () {\n      var _createRelayHubFromRecipient = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(recipientAddress) {\n        var relayRecipient, relayHubAddress, relayHub, hubVersion;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                relayRecipient = this.createRelayRecipient(recipientAddress);\n                _context5.prev = 1;\n                _context5.next = 4;\n                return relayRecipient.methods.getHubAddr().call();\n\n              case 4:\n                relayHubAddress = _context5.sent;\n                _context5.next = 10;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](1);\n                throw new Error(\"Could not get relay hub address from recipient at \".concat(recipientAddress, \" (\").concat(_context5.t0.message, \"). Make sure it is a valid recipient contract.\"));\n\n              case 10:\n                if (!(!relayHubAddress || ethUtils.isZeroAddress(relayHubAddress))) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                throw new Error(\"The relay hub address is set to zero in recipient at \".concat(recipientAddress, \". Make sure it is a valid recipient contract.\"));\n\n              case 12:\n                relayHub = this.createRelayHub(relayHubAddress);\n                _context5.prev = 13;\n                _context5.next = 16;\n                return relayHub.methods.version().call();\n\n              case 16:\n                hubVersion = _context5.sent;\n                _context5.next = 22;\n                break;\n\n              case 19:\n                _context5.prev = 19;\n                _context5.t1 = _context5[\"catch\"](13);\n                throw new Error(\"Could not query relay hub version at \".concat(relayHubAddress, \" (\").concat(_context5.t1.message, \"). Make sure the address corresponds to a relay hub.\"));\n\n              case 22:\n                if (hubVersion.startsWith('1')) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                throw new Error(\"Unsupported relay hub version '\".concat(hubVersion, \"'.\"));\n\n              case 24:\n                return _context5.abrupt(\"return\", relayHub);\n\n              case 25:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 7], [13, 19]]);\n      }));\n\n      function createRelayHubFromRecipient(_x8) {\n        return _createRelayHubFromRecipient.apply(this, arguments);\n      }\n\n      return createRelayHubFromRecipient;\n    }()\n  }], [{\n    key: \"newEphemeralKeypair\",\n    value: function newEphemeralKeypair() {\n      var a = ethWallet.generate();\n      return {\n        privateKey: a.privKey,\n        address: \"0x\" + a.getAddress().toString('hex')\n      };\n    }\n  }]);\n\n  return RelayClient;\n}();\n\nmodule.exports = RelayClient;","map":null,"metadata":{},"sourceType":"script"}
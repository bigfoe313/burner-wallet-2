{"ast":null,"code":"const Web3 = require('web3');\n\nconst _require = require('web3-utils'),\n      toBN = _require.toBN;\n\nconst cookies = require('../lib/cookies');\n\nconst Signer = require('./Signer');\n\nclass LocalSigner extends Signer {\n  constructor({\n    privateKey,\n    saveKey = true,\n    gasMultiplier = 1\n  } = {}) {\n    super({\n      id: 'local'\n    });\n    this._saveKey = saveKey;\n    this.gasMultiplier = gasMultiplier;\n\n    if (this._isValidPK(privateKey)) {\n      this._generateAccountFromPK(privateKey);\n    } else {\n      this._loadOrGenerateAccount();\n    }\n  }\n\n  getAccounts() {\n    return [this.account.address];\n  }\n\n  async signTx(tx) {\n    const _tx = { ...tx,\n      // Workaround for https://github.com/ethereumjs/ethereumjs-tx/pull/195\n      common: {\n        customChain: {\n          chainId: tx.chainId,\n          networkId: tx.chainId\n        },\n        hardfork: 'istanbul'\n      }\n    };\n\n    if (this.gasMultiplier !== 1) {\n      const multiplier = Math.floor(this.gasMultiplier * 1000).toString();\n      _tx.gas = toBN(tx.gas).mul(toBN(multiplier)).div(toBN('1000'));\n    }\n\n    const _ref = await this.account.signTransaction(_tx),\n          rawTransaction = _ref.rawTransaction;\n\n    _tx.signedTransaction = rawTransaction;\n    return _tx;\n  }\n\n  async signMsg(msg) {\n    return this.account.sign(msg).signature;\n  }\n\n  permissions() {\n    return ['readKey', 'writeKey', 'burn', 'keyToAddress'];\n  }\n\n  invoke(action, account, ...params) {\n    if (!this.hasAccount(account)) {\n      throw new Error('Can not call invoke, incorrect account');\n    }\n\n    switch (action) {\n      case 'readKey':\n        return this.account.privateKey;\n\n      case 'writeKey':\n        const newPK = params[0];\n\n        this._generateAccountFromPK(newPK);\n\n        return this.account.address;\n\n      case 'burn':\n        this._generateNewAccount();\n\n        return this.account.address;\n\n      case 'keyToAddress':\n        const pk = params[0];\n\n        const _eth$accounts$private = new Web3().eth.accounts.privateKeyToAccount(pk),\n              address = _eth$accounts$private.address;\n\n        return address;\n\n      default:\n        throw new Error(\"Unknown action \".concat(action));\n    }\n  }\n\n  _isValidPK(pk) {\n    return !!pk && parseInt(pk) > 0;\n  }\n\n  _loadOrGenerateAccount() {\n    const pk = window.localStorage && localStorage.getItem('metaPrivateKey') || cookies.getCookie('metaPrivateKey');\n\n    if (this._isValidPK(pk)) {\n      this._generateAccountFromPK(pk);\n    } else {\n      this._generateNewAccount();\n    }\n  }\n\n  _generateAccountFromPK(privateKey) {\n    this.account = new Web3().eth.accounts.privateKeyToAccount(privateKey);\n\n    this._saveAccount();\n\n    this.events.emit('accountChange');\n  }\n\n  _generateNewAccount() {\n    this.account = new Web3().eth.accounts.create();\n\n    this._saveAccount();\n\n    this.events.emit('accountChange');\n  }\n\n  _saveAccount() {\n    if (!this._saveKey) {\n      return;\n    }\n\n    const privateKey = this.account.privateKey;\n\n    if (!privateKey || !/^0x[0-9a-fA-F]{64}$/.test(privateKey)) {\n      throw new Error(\"Invalid Private Key \\\"\".concat(privateKey, \"\\\"\"));\n    }\n\n    if (window.localStorage) {\n      localStorage.setItem('metaPrivateKey', this.account.privateKey);\n    }\n\n    cookies.setCookie('metaPrivateKey', this.account.privateKey);\n  }\n\n}\n\nmodule.exports = LocalSigner;","map":null,"metadata":{},"sourceType":"script"}
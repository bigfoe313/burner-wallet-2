{"ast":null,"code":"const BN = require('web3').utils.toBN; //relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\n\n\nconst DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nclass ActiveRelayPinger {\n  // TODO: 'httpSend' should be on a network layer\n  constructor(filteredRelays, httpSend, gasPrice, verbose) {\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n  }\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n\n\n  async nextRelay() {\n    if (this.remainingRelays.length === 0) {\n      return null;\n    }\n\n    while (this.remainingRelays.length) {\n      let bulkSize = Math.min(3, this.remainingRelays.length);\n\n      try {\n        let slice = this.remainingRelays.slice(0, bulkSize);\n\n        if (this.verbose) {\n          console.log(\"nextRelay: find fastest relay from: \" + JSON.stringify(slice));\n        }\n\n        let firstRelayToRespond = await this.raceToSuccess(slice.map(relay => this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, this.gasPrice)));\n\n        if (this.verbose) {\n          console.log(\"race finished with a champion: \" + firstRelayToRespond.relayUrl);\n        }\n\n        this.remainingRelays = this.remainingRelays.filter(a => a.relayUrl !== firstRelayToRespond.relayUrl);\n        this.pingedRelays++;\n        return firstRelayToRespond;\n      } catch (e) {\n        console.log(\"One batch of relays failed, last error: \", e); //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n\n        this.remainingRelays = this.remainingRelays.slice(bulkSize);\n      }\n    }\n  }\n  /**\n   * @returns JSON response from the relay server, but adds the requested URL to it:\n   * { relayUrl: url,\n   *   transactionFee: fee,\n   *   RelayServerAddress: address,\n   *   Ready: bool,   //should ignore relays with \"false\"\n   *   MinGasPrice:   //minimum gas requirement by this relay.\n   * }\n   */\n\n\n  async getRelayAddressPing(relayUrl, transactionFee, gasPrice) {\n    let self = this;\n    return new Promise(function (resolve, reject) {\n      let callback = function (error, body) {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        if (!body || !body.Ready || body.MinGasPrice > gasPrice) {\n          reject(\"Relay not ready or proposed gas price too low \" + JSON.stringify(body));\n          return;\n        }\n\n        try {\n          //add extra attributes (relayUrl, transactionFee)\n          Object.assign(body, {\n            relayUrl,\n            transactionFee\n          });\n          resolve(body);\n        } catch (err) {\n          reject(err);\n        }\n      };\n\n      if (self.verbose) {\n        console.log(\"getRelayAddressPing URL: \" + relayUrl);\n      }\n\n      self.httpSend.send(relayUrl + \"/getaddr\", {}, callback);\n    });\n  }\n  /**\n   * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n   * Resolves once any promise resolves, ignores the rest, ignores rejections\n   */\n\n\n  async raceToSuccess(promises) {\n    let numRejected = 0;\n    return new Promise((resolve, reject) => promises.forEach(promise => promise.then(res => {\n      resolve(res);\n    }).catch(err => {\n      if (++numRejected === promises.length) {\n        reject(\"No response matched filter from any server: \" + err);\n      }\n    })));\n  }\n\n}\n\nclass ServerHelper {\n  constructor(httpSend, failedRelays, {\n    verbose,\n    minStake,\n    minDelay,\n    //params for relayFilter: filter out this relay if unstakeDelay or stake are too low.\n    relayTimeoutGrace,\n    //ignore score drop of a relay after this time (seconds)\n    calculateRelayScore,\n    //function: return relay score, higher the better. default uses transactionFee and some randomness\n    relayFilter,\n    //function: return false to filter out a relay. default uses minStake, minDelay\n    addScoreRandomness //function: return Math.random (0..1), to fairly distribute among relays with same score.\n    // (used by test to REMOVE the randomness, and make the test deterministic.\n\n  }) {\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this); //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n\n    this.relayFilter = relayFilter || (relay => relay.score != null && (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) && (!minStake || BN(relay.stake).gte(BN(minStake))));\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  defaultCalculateRelayScore(relay) {\n    //basic score is trasnaction fee (which is %)\n    //higher the better.\n    let score = 1000 - relay.transactionFee;\n    let failedRelay = this.failedRelays[relay.relayUrl];\n\n    if (failedRelay) {\n      const elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n      if (elapsed < this.relayTimeoutGrace) score -= 10; //relay failed to answer lately. demote.\n      else delete this.failedRelays[relay.relayUrl];\n    }\n\n    return score;\n  } //compare relay scores.\n  // if they are the same, use addScoreRandomness to shuffle them..\n\n\n  compareRelayScores(r1, r2) {\n    let diff = r2.score - r1.score;\n    if (diff) return diff;\n    return this.addScoreRandomness() - 0.5;\n  }\n  /**\n   *\n   * @param {*} relayHubInstance\n   */\n\n\n  setHub(relayHubInstance) {\n    if (this.relayHubInstance !== relayHubInstance) {\n      this.filteredRelays = [];\n    }\n\n    this.relayHubInstance = relayHubInstance;\n  }\n\n  async newActiveRelayPinger(fromBlock, gasPrice) {\n    if (typeof this.relayHubInstance === 'undefined') {\n      throw new Error(\"Must call to setHub first!\");\n    }\n\n    if (this.filteredRelays.length == 0 || this.fromBlock !== fromBlock) {\n      this.fromBlock = fromBlock;\n      await this.fetchRelaysAdded();\n    }\n\n    return this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose);\n  }\n\n  createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n  }\n  /**\n   * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n   * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n   */\n\n\n  async fetchRelaysAdded() {\n    let activeRelays = {};\n    let fromBlock = this.fromBlock || 2;\n    let addedAndRemovedEvents = await this.relayHubInstance.getPastEvents(\"allEvents\", {\n      fromBlock: fromBlock // topics: [[\"RelayAdded\", \"RelayRemoved\"]]\n\n    });\n\n    if (this.verbose) {\n      console.log(\"fetchRelaysAdded: found \" + addedAndRemovedEvents.length + \" events\");\n    } //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n    //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n\n\n    for (var index in addedAndRemovedEvents) {\n      let event = addedAndRemovedEvents[index];\n\n      if (event.event === \"RelayAdded\") {\n        let args = event.returnValues;\n        let relay = {\n          address: args.relay,\n          relayUrl: args.url,\n          transactionFee: args.transactionFee,\n          stake: args.stake,\n          unstakeDelay: args.unstakeDelay\n        };\n        relay.score = this.calculateRelayScore(relay);\n        activeRelays[args.relay] = relay;\n      } else if (event.event === \"RelayRemoved\") {\n        delete activeRelays[event.returnValues.relay];\n      }\n    }\n\n    const origRelays = Object.values(activeRelays);\n    const filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n\n    if (filteredRelays.length == 0) {\n      throw new Error(\"no valid relays. orig relays=\" + JSON.stringify(origRelays));\n    }\n\n    if (this.verbose) {\n      console.log(\"fetchRelaysAdded: after filtering have \" + filteredRelays.length + \" active relays\");\n    }\n\n    this.filteredRelays = filteredRelays;\n    this.isInitialized = true;\n    return filteredRelays;\n  }\n\n}\n\nmodule.exports = ServerHelper;","map":null,"metadata":{},"sourceType":"script"}
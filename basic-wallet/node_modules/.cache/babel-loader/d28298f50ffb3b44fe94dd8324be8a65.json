{"ast":null,"code":"const utils = require('./utils');\n\nconst getTransactionSignature = utils.getTransactionSignature;\nconst getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nconst parseHexString = utils.parseHexString;\nconst removeHexPrefix = utils.removeHexPrefix;\nconst padTo64 = utils.padTo64;\n\nconst ServerHelper = require('./ServerHelper');\n\nconst HttpWrapper = require('./HttpWrapper');\n\nconst ethUtils = require('ethereumjs-util');\n\nconst ethWallet = require('ethereumjs-wallet');\n\nconst ethJsTx = require('ethereumjs-tx');\n\nconst abi_decoder = require('abi-decoder');\n\nconst relayHubAbi = require('./IRelayHub'); // This file is only needed so we don't change IRelayHub code, which would affect RelayHub expected deployed address\n// TODO: Once we change RelayHub version, we should add abstract method \"function version() external returns (string memory);\" to IRelayHub.sol and remove IRelayHubVersionAbi.json\n\n\nconst versionAbi = require('./IRelayHubVersionAbi');\n\nrelayHubAbi.push(versionAbi);\n\nconst relayRecipientAbi = require('./IRelayRecipient');\n\nconst relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi); // default timeout (in ms) for http requests\n\nconst DEFAULT_HTTP_TIMEOUT = 10000; //default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\n\nconst GASPRICE_PERCENT = 20;\nconst canRelayStatus = {\n  1: \"1 WrongSignature\",\n  // The transaction to relay is not signed by requested sender\n  2: \"2 WrongNonce\",\n  // The provided nonce has already been used by the sender\n  3: \"3 AcceptRelayedCallReverted\",\n  // The recipient rejected this call via acceptRelayedCall\n  4: \"4 InvalidRecipientStatusCode\" // The recipient returned an invalid (reserved) status code\n\n};\n\nclass RelayClient {\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *    validateCanRelay - client calls canRelay before calling the relay the first time (defaults to true)\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    relayUrl, relayAddress - avoid lookup on relayHub for relays, and always use this URL/address\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  constructor(web3, config) {\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign({\n      validateCanRelay: true,\n      httpTimeout: DEFAULT_HTTP_TIMEOUT\n    }, config);\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({\n      timeout: this.config.httpTimeout\n    });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  createRelayRecipient(addr) {\n    return new this.web3.eth.Contract(relayRecipientAbi, addr);\n  }\n\n  createRelayHub(addr) {\n    return new this.web3.eth.Contract(relayHubAbi, addr);\n  }\n  /**\n   * Decode the signed transaction returned from the Relay Server, compare it to the\n   * requested transaction and validate its signature.\n   * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n   * transaction is not valid.\n   */\n\n\n  validateRelayResponse(returned_tx, address_relay, from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address, sig, approvalData) {\n    var tx = new ethJsTx({\n      nonce: returned_tx.nonce,\n      gasPrice: returned_tx.gasPrice,\n      gasLimit: returned_tx.gas,\n      to: returned_tx.to,\n      value: returned_tx.value,\n      data: returned_tx.input\n    });\n    let message = tx.hash(false);\n    let tx_v = Buffer.from(removeHexPrefix(returned_tx.v), \"hex\");\n    let tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), \"hex\");\n    let tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), \"hex\");\n    let signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n    let request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n    let returned_tx_params_hash = utils.getTransactionHash(request_decoded_params[0].value, request_decoded_params[1].value, request_decoded_params[2].value, request_decoded_params[3].value, request_decoded_params[4].value, request_decoded_params[5].value, request_decoded_params[6].value, returned_tx.to, signer);\n    let transaction_orig_params_hash = utils.getTransactionHash(from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address);\n\n    if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n      if (this.config.verbose) {\n        console.log(\"validateRelayResponse - valid transaction response\");\n      }\n\n      tx.v = tx_v;\n      tx.r = tx_r;\n      tx.s = tx_s;\n      return tx;\n    } else {\n      console.error(\"validateRelayResponse: req\", JSON.stringify(request_decoded_params));\n      console.error(\"validateRelayResponse: rsp\", {\n        returned_tx,\n        address_relay,\n        from,\n        to,\n        transaction_orig,\n        transaction_fee,\n        gas_price,\n        gas_limit,\n        nonce,\n        sig,\n        approvalData,\n        signer\n      });\n    }\n  }\n  /**\n   * Performs a '/relay' HTTP request to the given url\n   * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n   */\n\n\n  sendViaRelay(relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, signature, approvalData, relayUrl, relayHubAddress, relayMaxNonce) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      let jsonRequestData = {\n        \"encodedFunction\": encodedFunction,\n        \"signature\": parseHexString(signature.replace(/^0x/, '')),\n        \"approvalData\": parseHexString(approvalData.replace(/^0x/, '')),\n        \"from\": from,\n        \"to\": to,\n        \"gasPrice\": gasprice,\n        \"gasLimit\": gaslimit,\n        \"relayFee\": relayFee,\n        \"RecipientNonce\": parseInt(recipientNonce),\n        \"RelayMaxNonce\": parseInt(relayMaxNonce),\n        \"RelayHubAddress\": relayHubAddress\n      };\n\n      let callback = async function (error, body) {\n        if (error) {\n          if (error.error && error.error.indexOf(\"timeout\") != -1) {\n            self.failedRelays[relayUrl] = {\n              lastError: new Date().getTime(),\n              address: relayAddress,\n              url: relayUrl\n            };\n          }\n\n          reject(error);\n          return;\n        }\n\n        if (self.config.verbose) {\n          console.log(\"sendViaRelay resp=\", body);\n        }\n\n        if (body && body.error) {\n          reject(body.error);\n          return;\n        }\n\n        if (!body || !body.nonce) {\n          reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n          return;\n        }\n\n        let validTransaction;\n\n        try {\n          validTransaction = self.validateRelayResponse(body, relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, relayHubAddress, relayAddress, signature, approvalData);\n        } catch (error) {\n          console.error(\"validateRelayResponse \" + error);\n        }\n\n        if (!validTransaction) {\n          reject(\"Failed to validate response\");\n          return;\n        }\n\n        let receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n\n        if (receivedNonce > relayMaxNonce) {\n          // TODO: need to validate that client retries the same request and doesn't double-spend.\n          // Note that this transaction is totally valid from the EVM's point of view\n          reject(\"Relay used a tx nonce higher than requested. Requested \" + relayMaxNonce + \" got \" + receivedNonce);\n          return;\n        }\n\n        var raw_tx = '0x' + validTransaction.serialize().toString('hex');\n        let txHash = \"0x\" + validTransaction.hash(true).toString('hex');\n        console.log(\"txHash= \" + txHash);\n        self.broadcastRawTx(raw_tx, txHash);\n        resolve(validTransaction);\n      };\n\n      if (self.config.verbose) {\n        let replacer = (key, value) => {\n          if (key === \"signature\") return signature;else return value;\n        };\n\n        console.log(\"sendViaRelay to URL: \" + relayUrl + \" \" + JSON.stringify(jsonRequestData, replacer));\n      }\n\n      self.httpSend.send(relayUrl + \"/relay\", jsonRequestData, callback);\n    });\n  }\n  /**\n   * In case Relay Server does not broadcast the signed transaction to the network,\n   * client also broadcasts the same transaction. If the transaction fails with nonce\n   * error, it indicates Relay may have signed multiple transactions with same nonce,\n   * causing a DoS attack.\n   *\n   * @param {*} raw_tx - raw transaction bytes, signed by relay\n   * @param {*} tx_hash - this transaction's ID\n   */\n\n\n  broadcastRawTx(raw_tx, tx_hash) {\n    var self = this;\n    self.web3.eth.sendSignedTransaction(raw_tx, function (error, result) {\n      //TODO: at this point both client and relay has sent the transaction to the blockchain.\n      // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n      // to penalize original relay for cheating: returning one transaction to the client, and\n      // broadcasting another with the same nonce.\n      // see the EIP for description of the attack\n      //don't display error for the known-good cases\n      if (!(\"\" + error).match(/the tx doesn't have the correct nonce|known transaction/)) console.log(\"broadcastTx: \", error || result);\n\n      if (error) {//note that nonce-related errors at this point are VALID reponses: it means that\n        // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n        // the only point is that different node versions return different error strings:\n        // ganache:  \"the tx doesn't have the correct nonce\"\n        // ropsten: \"known transaction\"\n      } else {\n        if (result == tx_hash) {//transaction already on chain\n        }\n      }\n    });\n  }\n  /**\n   * check the balance of the given target contract.\n   * the method will fail if the target is not a RelayRecipient.\n   * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n   */\n\n\n  async balanceOf(target) {\n    const relayHub = await this.createRelayHubFromRecipient(target); //note that the returned value is a promise too, returning BigNumber\n\n    return relayHub.methods.balanceOf(target).call();\n  }\n  /**\n   * Options include standard transaction params: from,to, gas_price, gas_limit\n   * relay-specific params:\n   *  txfee (override config.txfee)\n   *  validateCanRelay - client calls canRelay before calling the relay the first time (defaults to true)\n   * can also override default relayUrl, relayFee\n   * return value is the same as from sendTransaction\n   */\n\n\n  async relayTransaction(encodedFunctionCall, options) {\n    //validateCanRelay defaults (in config). to disable, explicitly set options.validateCanRelay=false\n    options = Object.assign({\n      validateCanRelay: this.config.validateCanRelay\n    }, options);\n    var self = this;\n    const relayHub = await this.createRelayHubFromRecipient(options.to);\n    var nonce = parseInt((await relayHub.methods.getNonce(options.from).call()));\n    this.serverHelper.setHub(relayHub); //gas-price multiplicator: either default (10%) or configuration factor\n\n    let pct = this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n    let network_gas_price = await this.web3.eth.getGasPrice(); // Sometimes, xDai netwiork returns '0'\n\n    if (!network_gas_price || network_gas_price == 0) {\n      network_gas_price = 1e9;\n    }\n\n    let gasPrice = this.config.force_gasPrice || //forced gasprice\n    options.gas_price || //user-supplied gas price\n    Math.round(network_gas_price * (pct + 100) / 100); //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n\n    let gasLimit = this.config.force_gasLimit || options.gas_limit;\n    let blockNow = await this.web3.eth.getBlockNumber();\n    let blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n    let pinger = await this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n    let errors = [];\n    let firstTry = true;\n\n    for (;;) {\n      let activeRelay = await pinger.nextRelay();\n\n      if (!activeRelay) {\n        let error = new Error(\"No relay responded! \" + pinger.relaysCount + \" attempted, \" + pinger.pingedRelays + \" pinged\");\n        error.otherErrors = errors;\n        throw error;\n      }\n\n      let relayAddress = activeRelay.RelayServerAddress;\n      let relayUrl = activeRelay.relayUrl;\n      let txfee = parseInt(options.txfee || activeRelay.transactionFee);\n      let hash = utils.getTransactionHash(options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, relayHub._address, relayAddress);\n      let signature;\n\n      if (typeof self.ephemeralKeypair === \"object\" && self.ephemeralKeypair !== null) {\n        signature = await getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n      } else {\n        signature = await getTransactionSignature(this.web3, options.from, hash);\n      }\n\n      let approvalData = \"0x\";\n\n      if (typeof options.approveFunction === \"function\") {\n        approvalData = \"0x\" + (await options.approveFunction({\n          from: options.from,\n          to: options.to,\n          encodedFunctionCall: encodedFunctionCall,\n          txfee: options.txfee,\n          gas_price: gasPrice,\n          gas_limit: gasLimit,\n          nonce: nonce,\n          relay_hub_address: relayHub._address,\n          relay_address: relayAddress\n        }));\n      }\n\n      if (self.config.verbose) {\n        console.log(\"relayTransaction hash: \", hash, \"from: \", options.from, \"sig: \", signature);\n        let rec = utils.getEcRecoverMeta(hash, signature);\n\n        if (rec.toLowerCase() === options.from.toLowerCase()) {\n          console.log(\"relayTransaction recovered:\", rec, \"signature is correct\");\n        } else {\n          console.error(\"relayTransaction recovered:\", rec, \"signature error\");\n        }\n      } // max nonce is not signed, as contracts cannot access addresses' nonces.\n\n\n      let allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap;\n\n      if (typeof allowed_relay_nonce_gap === \"undefined\") {\n        allowed_relay_nonce_gap = 3;\n      }\n\n      let relayMaxNonce = (await this.web3.eth.getTransactionCount(relayAddress)) + allowed_relay_nonce_gap; //on first found relay, call canRelay to make sure that on-chain this request can pass\n\n      if (options.validateCanRelay && firstTry) {\n        firstTry = false;\n        let res = await relayHub.methods.canRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData).call();\n\n        if (res.status != 0) {\n          //in case of error, the context is an error message.\n          let errorMsg = res.recipientContext ? Buffer.from(res.recipientContext.slice(2), 'hex').toString() : \"\";\n          let status = canRelayStatus[res.status] || res.status;\n          throw new Error(\"canRelay failed: \" + status + \": \" + errorMsg);\n        }\n      }\n\n      try {\n        let validTransaction = await self.sendViaRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData, relayUrl, relayHub._address, relayMaxNonce);\n        return validTransaction;\n      } catch (error) {\n        errors.push(error);\n\n        if (self.config.verbose) {\n          console.log(\"relayTransaction: req:\", {\n            from: options.from,\n            to: options.to,\n            encodedFunctionCall,\n            txfee: options.txfee,\n            gasPrice,\n            gasLimit,\n            nonce,\n            relayhub: relayHub._address,\n            relayAddress\n          });\n          console.log(\"relayTransaction:\", (\"\" + error).replace(/ (\\w+:)/g, \"\\n$1 \"));\n        }\n      }\n    }\n  }\n\n  fixTransactionReceiptResp(respResult) {\n    if (respResult && respResult.logs) {\n      let logs = abi_decoder.decodeLogs(respResult.logs);\n      let canRelayFailed = logs.find(e => e && e.name == 'CanRelayFailed');\n      let transactionRelayed = logs.find(e => e && e.name == 'TransactionRelayed');\n\n      const setErrorStatus = reason => {\n        console.log(\"\".concat(reason, \". changing status to zero\"));\n        respResult.status = 0;\n      };\n\n      if (canRelayFailed) {\n        setErrorStatus(\"canRelay failed: \".concat(canRelayFailed.events.find(e => e.name == \"reason\").value));\n      } else if (transactionRelayed) {\n        const status = transactionRelayed.events.find(e => e.name == \"status\").value;\n\n        if (status != 0) {\n          // 0 signifies success\n          setErrorStatus(\"reverted relayed transaction, status code \".concat(status));\n        }\n      }\n    }\n  }\n\n  runRelay(payload, callback) {\n    let params = payload.params[0];\n    let relayClientOptions = this.config;\n    let relayOptions = {\n      from: params.from,\n      to: params.to,\n      txfee: params.txFee || params.txfee || relayClientOptions.txfee,\n      gas_limit: params.gas && parseInt(params.gas, 16),\n      gas_price: params.gasPrice && parseInt(params.gasPrice, 16)\n    };\n    if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n    this.relayTransaction(params.data, relayOptions).then(validTransaction => {\n      var hash = \"0x\" + validTransaction.hash(true).toString('hex');\n      callback(null, {\n        jsonrpc: '2.0',\n        id: payload.id,\n        result: hash\n      });\n    }).catch(err => {\n      if (relayClientOptions.verbose) console.log(\"RR error: \", err);\n      callback(err, null);\n    });\n  }\n\n  postAuditTransaction(signedTx, relayUrl) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n      let callback = function (error, response) {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response);\n      };\n\n      self.httpSend.send(relayUrl + \"/audit\", {\n        signedTx: signedTx\n      }, callback);\n    });\n  }\n  /**\n   * Send a transaction signed by a relay to other relays for audit.\n   * This is done in order to prevent nonce reuse by a misbehaving relay.\n   *\n   * @param {*} transaction\n   * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n   */\n\n\n  async auditTransaction(transaction, auditingRelays) {\n    for (let relay in auditingRelays) {\n      await this.postAuditTransaction(transaction, auditingRelays[relay]);\n    }\n  }\n\n  static newEphemeralKeypair() {\n    let a = ethWallet.generate();\n    return {\n      privateKey: a.privKey,\n      address: \"0x\" + a.getAddress().toString('hex')\n    };\n  }\n\n  useKeypairForSigning(ephemeralKeypair) {\n    if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n      ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), \"hex\");\n    }\n\n    this.ephemeralKeypair = ephemeralKeypair;\n  }\n\n  async createRelayHubFromRecipient(recipientAddress) {\n    const relayRecipient = this.createRelayRecipient(recipientAddress);\n    let relayHubAddress;\n\n    try {\n      relayHubAddress = await relayRecipient.methods.getHubAddr().call();\n    } catch (err) {\n      throw new Error(\"Could not get relay hub address from recipient at \".concat(recipientAddress, \" (\").concat(err.message, \"). Make sure it is a valid recipient contract.\"));\n    }\n\n    if (!relayHubAddress || ethUtils.isZeroAddress(relayHubAddress)) {\n      throw new Error(\"The relay hub address is set to zero in recipient at \".concat(recipientAddress, \". Make sure it is a valid recipient contract.\"));\n    }\n\n    const relayHub = this.createRelayHub(relayHubAddress);\n    let hubVersion;\n\n    try {\n      hubVersion = await relayHub.methods.version().call();\n    } catch (err) {\n      throw new Error(\"Could not query relay hub version at \".concat(relayHubAddress, \" (\").concat(err.message, \"). Make sure the address corresponds to a relay hub.\"));\n    }\n\n    if (!hubVersion.startsWith('1')) {\n      throw new Error(\"Unsupported relay hub version '\".concat(hubVersion, \"'.\"));\n    }\n\n    return relayHub;\n  }\n\n}\n\nmodule.exports = RelayClient;","map":null,"metadata":{},"sourceType":"script"}
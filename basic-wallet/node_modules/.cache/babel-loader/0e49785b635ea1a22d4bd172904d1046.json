{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BN = require('web3').utils.toBN; //relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\n\n\nvar DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nvar ActiveRelayPinger =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  // TODO: 'httpSend' should be on a network layer\n  function ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    _classCallCheck(this, ActiveRelayPinger);\n\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n  }\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n\n\n  _createClass(ActiveRelayPinger, [{\n    key: \"nextRelay\",\n    value: function () {\n      var _nextRelay = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        var bulkSize, _ret;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.remainingRelays.length === 0)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", null);\n\n              case 2:\n                if (!this.remainingRelays.length) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                bulkSize = Math.min(3, this.remainingRelays.length);\n                _context2.prev = 4;\n                return _context2.delegateYield(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee() {\n                  var slice, firstRelayToRespond;\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          slice = _this.remainingRelays.slice(0, bulkSize);\n\n                          if (_this.verbose) {\n                            console.log(\"nextRelay: find fastest relay from: \" + JSON.stringify(slice));\n                          }\n\n                          _context.next = 4;\n                          return _this.raceToSuccess(slice.map(function (relay) {\n                            return _this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, _this.gasPrice);\n                          }));\n\n                        case 4:\n                          firstRelayToRespond = _context.sent;\n\n                          if (_this.verbose) {\n                            console.log(\"race finished with a champion: \" + firstRelayToRespond.relayUrl);\n                          }\n\n                          _this.remainingRelays = _this.remainingRelays.filter(function (a) {\n                            return a.relayUrl !== firstRelayToRespond.relayUrl;\n                          });\n                          _this.pingedRelays++;\n                          return _context.abrupt(\"return\", {\n                            v: firstRelayToRespond\n                          });\n\n                        case 9:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })(), \"t0\", 6);\n\n              case 6:\n                _ret = _context2.t0;\n\n                if (!(typeof _ret === \"object\")) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _ret.v);\n\n              case 9:\n                _context2.next = 15;\n                break;\n\n              case 11:\n                _context2.prev = 11;\n                _context2.t1 = _context2[\"catch\"](4);\n                console.log(\"One batch of relays failed, last error: \", _context2.t1); //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n\n                this.remainingRelays = this.remainingRelays.slice(bulkSize);\n\n              case 15:\n                _context2.next = 2;\n                break;\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 11]]);\n      }));\n\n      function nextRelay() {\n        return _nextRelay.apply(this, arguments);\n      }\n\n      return nextRelay;\n    }()\n    /**\n     * @returns JSON response from the relay server, but adds the requested URL to it:\n     * { relayUrl: url,\n     *   transactionFee: fee,\n     *   RelayServerAddress: address,\n     *   Ready: bool,   //should ignore relays with \"false\"\n     *   MinGasPrice:   //minimum gas requirement by this relay.\n     * }\n     */\n\n  }, {\n    key: \"getRelayAddressPing\",\n    value: function () {\n      var _getRelayAddressPing = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(relayUrl, transactionFee, gasPrice) {\n        var self;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                self = this;\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var callback = function callback(error, body) {\n                    if (error) {\n                      reject(error);\n                      return;\n                    }\n\n                    if (!body || !body.Ready || body.MinGasPrice > gasPrice) {\n                      reject(\"Relay not ready or proposed gas price too low \" + JSON.stringify(body));\n                      return;\n                    }\n\n                    try {\n                      //add extra attributes (relayUrl, transactionFee)\n                      Object.assign(body, {\n                        relayUrl: relayUrl,\n                        transactionFee: transactionFee\n                      });\n                      resolve(body);\n                    } catch (err) {\n                      reject(err);\n                    }\n                  };\n\n                  if (self.verbose) {\n                    console.log(\"getRelayAddressPing URL: \" + relayUrl);\n                  }\n\n                  self.httpSend.send(relayUrl + \"/getaddr\", {}, callback);\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getRelayAddressPing(_x, _x2, _x3) {\n        return _getRelayAddressPing.apply(this, arguments);\n      }\n\n      return getRelayAddressPing;\n    }()\n    /**\n     * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n     * Resolves once any promise resolves, ignores the rest, ignores rejections\n     */\n\n  }, {\n    key: \"raceToSuccess\",\n    value: function () {\n      var _raceToSuccess = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(promises) {\n        var numRejected;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                numRejected = 0;\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return promises.forEach(function (promise) {\n                    return promise.then(function (res) {\n                      resolve(res);\n                    }).catch(function (err) {\n                      if (++numRejected === promises.length) {\n                        reject(\"No response matched filter from any server: \" + err);\n                      }\n                    });\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function raceToSuccess(_x4) {\n        return _raceToSuccess.apply(this, arguments);\n      }\n\n      return raceToSuccess;\n    }()\n  }]);\n\n  return ActiveRelayPinger;\n}();\n\nvar ServerHelper =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function ServerHelper(httpSend, failedRelays, _ref) {\n    var verbose = _ref.verbose,\n        minStake = _ref.minStake,\n        minDelay = _ref.minDelay,\n        relayTimeoutGrace = _ref.relayTimeoutGrace,\n        calculateRelayScore = _ref.calculateRelayScore,\n        relayFilter = _ref.relayFilter,\n        addScoreRandomness = _ref.addScoreRandomness;\n\n    _classCallCheck(this, ServerHelper);\n\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this); //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n\n    this.relayFilter = relayFilter || function (relay) {\n      return relay.score != null && (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) && (!minStake || BN(relay.stake).gte(BN(minStake)));\n    };\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  _createClass(ServerHelper, [{\n    key: \"defaultCalculateRelayScore\",\n    value: function defaultCalculateRelayScore(relay) {\n      //basic score is trasnaction fee (which is %)\n      //higher the better.\n      var score = 1000 - relay.transactionFee;\n      var failedRelay = this.failedRelays[relay.relayUrl];\n\n      if (failedRelay) {\n        var elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n        if (elapsed < this.relayTimeoutGrace) score -= 10; //relay failed to answer lately. demote.\n        else delete this.failedRelays[relay.relayUrl];\n      }\n\n      return score;\n    } //compare relay scores.\n    // if they are the same, use addScoreRandomness to shuffle them..\n\n  }, {\n    key: \"compareRelayScores\",\n    value: function compareRelayScores(r1, r2) {\n      var diff = r2.score - r1.score;\n      if (diff) return diff;\n      return this.addScoreRandomness() - 0.5;\n    }\n    /**\n     *\n     * @param {*} relayHubInstance\n     */\n\n  }, {\n    key: \"setHub\",\n    value: function setHub(relayHubInstance) {\n      if (this.relayHubInstance !== relayHubInstance) {\n        this.filteredRelays = [];\n      }\n\n      this.relayHubInstance = relayHubInstance;\n    }\n  }, {\n    key: \"newActiveRelayPinger\",\n    value: function () {\n      var _newActiveRelayPinger = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(fromBlock, gasPrice) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(typeof this.relayHubInstance === 'undefined')) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Must call to setHub first!\");\n\n              case 2:\n                if (!(this.filteredRelays.length == 0 || this.fromBlock !== fromBlock)) {\n                  _context5.next = 6;\n                  break;\n                }\n\n                this.fromBlock = fromBlock;\n                _context5.next = 6;\n                return this.fetchRelaysAdded();\n\n              case 6:\n                return _context5.abrupt(\"return\", this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose));\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function newActiveRelayPinger(_x5, _x6) {\n        return _newActiveRelayPinger.apply(this, arguments);\n      }\n\n      return newActiveRelayPinger;\n    }()\n  }, {\n    key: \"createActiveRelayPinger\",\n    value: function createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n      return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n    }\n    /**\n     * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n     * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n     */\n\n  }, {\n    key: \"fetchRelaysAdded\",\n    value: function () {\n      var _fetchRelaysAdded = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6() {\n        var activeRelays, fromBlock, addedAndRemovedEvents, index, event, args, relay, origRelays, filteredRelays;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                activeRelays = {};\n                fromBlock = this.fromBlock || 2;\n                _context6.next = 4;\n                return this.relayHubInstance.getPastEvents(\"allEvents\", {\n                  fromBlock: fromBlock // topics: [[\"RelayAdded\", \"RelayRemoved\"]]\n\n                });\n\n              case 4:\n                addedAndRemovedEvents = _context6.sent;\n\n                if (this.verbose) {\n                  console.log(\"fetchRelaysAdded: found \" + addedAndRemovedEvents.length + \" events\");\n                } //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n                //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n\n\n                for (index in addedAndRemovedEvents) {\n                  event = addedAndRemovedEvents[index];\n\n                  if (event.event === \"RelayAdded\") {\n                    args = event.returnValues;\n                    relay = {\n                      address: args.relay,\n                      relayUrl: args.url,\n                      transactionFee: args.transactionFee,\n                      stake: args.stake,\n                      unstakeDelay: args.unstakeDelay\n                    };\n                    relay.score = this.calculateRelayScore(relay);\n                    activeRelays[args.relay] = relay;\n                  } else if (event.event === \"RelayRemoved\") {\n                    delete activeRelays[event.returnValues.relay];\n                  }\n                }\n\n                origRelays = Object.values(activeRelays);\n                filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n\n                if (!(filteredRelays.length == 0)) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                throw new Error(\"no valid relays. orig relays=\" + JSON.stringify(origRelays));\n\n              case 11:\n                if (this.verbose) {\n                  console.log(\"fetchRelaysAdded: after filtering have \" + filteredRelays.length + \" active relays\");\n                }\n\n                this.filteredRelays = filteredRelays;\n                this.isInitialized = true;\n                return _context6.abrupt(\"return\", filteredRelays);\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function fetchRelaysAdded() {\n        return _fetchRelaysAdded.apply(this, arguments);\n      }\n\n      return fetchRelaysAdded;\n    }()\n  }]);\n\n  return ServerHelper;\n}();\n\nmodule.exports = ServerHelper;","map":null,"metadata":{},"sourceType":"script"}
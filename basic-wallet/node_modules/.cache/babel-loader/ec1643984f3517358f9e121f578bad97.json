{"ast":null,"code":"import _slicedToArray from \"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport React, { Fragment, useState, useEffect, useRef } from 'react';\nimport { useBurner } from '../BurnerProvider';\nconst POLL_INTERVAL = 1000;\nconst CACHE_EXPIRATION = 3000;\nconst balanceCache = {};\n\nconst getCache = key => balanceCache[key] && Date.now() - balanceCache[key].timestamp < CACHE_EXPIRATION ? balanceCache[key] : null;\n\nconst setCache = (key, val) => {\n  balanceCache[key] = { ...val,\n    timestamp: Date.now()\n  };\n};\n\nconst getBalance = async (asset, account) => {\n  const cacheKey = \"\".concat(asset.id, \"-\").concat(account);\n  const cachedVal = getCache(cacheKey);\n\n  if (cachedVal) {\n    return cachedVal;\n  }\n\n  const _ref = await Promise.all([asset.getBalance(account), asset.getMaximumSendableBalance(account), asset.getGrowthRate ? asset.getGrowthRate(account) : Promise.resolve('0')]),\n        _ref2 = _slicedToArray(_ref, 3),\n        balance = _ref2[0],\n        maximumSendableBalance = _ref2[1],\n        growthRate = _ref2[2];\n\n  const returnVal = {\n    balance,\n    maximumSendableBalance,\n    growthRate\n  };\n  setCache(cacheKey, returnVal);\n  return returnVal;\n};\n\nconst AccountBalance = ({\n  render,\n  asset,\n  account\n}) => {\n  const _useState = useState(null),\n        _useState2 = _slicedToArray(_useState, 2),\n        data = _useState2[0],\n        setData = _useState2[1];\n\n  const dataRef = useRef(null);\n\n  const _isMounted = useRef(true);\n\n  const timer = useRef(null);\n\n  const _useBurner = useBurner(),\n        assets = _useBurner.assets,\n        defaultAccount = _useBurner.defaultAccount;\n\n  const _account = account || defaultAccount;\n\n  const getAsset = () => {\n    if (typeof asset !== 'string') {\n      return asset;\n    }\n\n    const assetList = assets.filter(_asset => _asset.id == asset);\n\n    if (assetList.length == 0) {\n      throw new Error(\"Unable to find asset \".concat(asset));\n    }\n\n    return assetList[0];\n  };\n\n  const fetchData = async () => {\n    try {\n      const _asset = getAsset();\n\n      const _ref3 = await getBalance(_asset, _account),\n            balance = _ref3.balance,\n            maximumSendableBalance = _ref3.maximumSendableBalance,\n            growthRate = _ref3.growthRate;\n\n      if (!_isMounted.current) {\n        return;\n      }\n\n      let usdBalance = null;\n\n      try {\n        usdBalance = _asset.getUSDValue(balance);\n      } catch (e) {}\n\n      const _data = {\n        asset: _asset,\n        balance,\n        displayBalance: _asset.getDisplayValue(balance),\n        maximumSendableBalance,\n        displayMaximumSendableBalance: _asset.getDisplayValue(maximumSendableBalance),\n        usdBalance,\n        growthRate\n      };\n\n      if (!dataRef.current || _data.balance !== dataRef.current.balance || _data.usdBalance !== dataRef.current.usdBalance) {\n        setData(_data);\n        dataRef.current = _data;\n      }\n    } catch (err) {\n      console.warn('[AccountBalance]', err);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n    let running = true;\n\n    const poll = async () => {\n      await fetchData();\n\n      if (running) {\n        timer.current = window.setTimeout(poll, POLL_INTERVAL);\n      }\n    };\n\n    poll();\n    return () => {\n      running = false;\n\n      if (timer.current) {\n        window.clearTimeout(timer.current);\n      }\n    };\n  }, [_account, asset]);\n  useEffect(() => {\n    return () => {\n      _isMounted.current = false;\n    };\n  }, []);\n  return React.createElement(Fragment, null, render(data));\n};\n\nexport default AccountBalance;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"const Web3 = require('web3');\n\nconst tabookey = require('@dmihal/tabookey-gasless');\n\nconst ProxyProvider = require('./ProxyProvider');\n\nconst EventEmitter = require('./lib/EventEmitter');\n\nconst History = require('./History');\n\nconst HistoryEvent = require('./HistoryEvent');\n\nconst TempSigner = require('./signers/TempSigner');\n\nclass BurnerCore {\n  constructor({\n    signers = [],\n    gateways = [],\n    assets = [],\n    historyOptions = {},\n    gsnGasLimit = 5000000,\n    gsnGasPrice = 1100000000\n  }) {\n    if (gateways.length === 0) {\n      throw new Error('Must include at least 1 gateway');\n    }\n\n    this.providers = {};\n    this.web3 = {};\n    this.gsnGasPrice = gsnGasPrice;\n    this.gsnGasLimit = gsnGasLimit;\n    this.events = new EventEmitter();\n    this.history = new History({\n      assets,\n      ...historyOptions\n    });\n    this.gateways = gateways;\n    this.gateways.forEach(gateway => gateway.setCore(this));\n    this.assets = assets;\n    this.assets.forEach(asset => {\n      asset.setCore(this);\n      asset.start && asset.start();\n    });\n    this.signers = signers;\n    this.signers.push(new TempSigner());\n    this.unsubscribesBySigner = {};\n    this.signers.forEach((signer, index) => {\n      signer.setCore(this);\n      this.unsubscribesBySigner[index] = this.watchAccounts(signer.getAccounts());\n      signer.onAccountChange(() => {\n        this.unsubscribesBySigner[index].forEach(unsubscribe => unsubscribe());\n        this.unsubscribesBySigner[index] = this.watchAccounts(signer.getAccounts());\n        this.events.emit('accountChange');\n      });\n    });\n  }\n\n  watchAccounts(accounts) {\n    const unsubscribes = [];\n\n    for (const account of accounts) {\n      for (const asset of this.assets) {\n        const unsubscribe = asset.startWatchingAddress(account);\n        unsubscribes.push(unsubscribe);\n      }\n    }\n\n    return unsubscribes;\n  }\n\n  onAccountChange(callback) {\n    this.events.on('accountChange', () => callback(this.getAccounts()));\n  }\n\n  getAssets() {\n    return this.assets;\n  }\n\n  getAccounts() {\n    const availableSigners = this.signers.filter(signer => signer.isAvailable());\n    return [].concat.apply([], availableSigners.map(signer => signer.getAccounts()));\n  }\n\n  async signTx(txParams) {\n    for (const signer of this.signers) {\n      if (signer.isAvailable() && signer.hasAccount(txParams.from)) {\n        const signed = await signer.signTx(txParams);\n        return signed;\n      }\n    }\n\n    throw new Error('Unable to find an appropriate signer');\n  }\n\n  async signMsg(msg, account) {\n    for (const signer of this.signers) {\n      if (signer.isAvailable() && signer.hasAccount(account)) {\n        const signed = await signer.signMsg(msg, account);\n        return signed;\n      }\n    }\n\n    throw new Error('Unable to find an appropriate signer');\n  }\n\n  shouldSkipSigning(network, txParams) {\n    for (const signer of this.signers) {\n      if (signer.isAvailable() && signer.hasAccount(txParams.from)) {\n        return signer.shouldSkipSigning(network);\n      }\n    }\n\n    throw new Error('Unable to find an appropriate signer');\n  }\n\n  async handleRequest(network, payload) {\n    for (const gateway of this.gateways) {\n      if (gateway.isAvailable() && gateway.getNetworks().indexOf(network) !== -1) {\n        const response = payload.method === 'eth_sendRawTransaction' && payload.params[0].signedTransaction ? await gateway.sendTx(network, payload) : await gateway.send(network, payload);\n        return response;\n      }\n    }\n\n    throw new Error(\"Could not find gateway for network \".concat(network));\n  }\n\n  getProvider(network, options = {}) {\n    const cacheKey = options.gasless ? \"\".concat(network, \"-gasless\") : network;\n\n    if (this.providers[cacheKey]) {\n      return this.providers[cacheKey];\n    }\n\n    let provider = new ProxyProvider(network, this);\n\n    if (options.gasless) {\n      provider = new tabookey.RelayProvider(provider, {\n        txfee: 70,\n        force_gasLimit: this.gsnGasLimit,\n        force_gasPrice: this.gsnGasPrice\n      });\n    }\n\n    this.providers[cacheKey] = provider;\n    return provider;\n  }\n\n  getWeb3(network, options = {}) {\n    const cacheKey = options.gasless ? \"\".concat(network, \"-gasless\") : network;\n\n    if (this.web3[cacheKey]) {\n      return this.web3[cacheKey];\n    }\n\n    this.web3[cacheKey] = new Web3(this.getProvider(network, options));\n    return this.web3[cacheKey];\n  }\n\n  canCallSigner(action, account) {\n    for (const signer of this.signers) {\n      if (account === signer.id || signer.isAvailable() && signer.hasAccount(account)) {\n        return signer.permissions().indexOf(action) !== -1;\n      }\n    }\n\n    return false;\n  }\n\n  callSigner(action, account, ...params) {\n    for (const signer of this.signers) {\n      if (signer.isAvailable() && signer.hasAccount(account)) {\n        return signer.invoke(action, account, ...params);\n      }\n\n      if (account === signer.id) {\n        return signer.invoke(action, ...params);\n      }\n    }\n\n    throw new Error(\"Unable to find signer for \".concat(account));\n  }\n\n  addHistoryEvent(eventProps) {\n    const event = new HistoryEvent(eventProps, this.assets);\n    this.history.addEvent(event);\n  }\n\n  getHistoryEvents(options) {\n    return this.history.getEvents(options);\n  }\n\n  onHistoryEvent(listener) {\n    this.history.onEvent(listener);\n  }\n\n  removeHistoryEventListener(listener) {\n    this.history.removeListener(listener);\n  }\n\n  stop() {\n    Object.values(this.providers).forEach(provider => provider.stop());\n    Object.values(this.gateways).forEach(gateway => gateway.stop());\n    this.assets.forEach(asset => asset.stop && asset.stop());\n  }\n\n}\n\nmodule.exports = BurnerCore;","map":null,"metadata":{},"sourceType":"script"}
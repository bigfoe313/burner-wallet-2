{"ast":null,"code":"const _require = require(\"web3-utils\"),\n      sha3 = _require.sha3,\n      BN = _require.BN;\n\nconst abiCoder = require(\"web3-eth-abi\");\n\nconst state = {\n  savedABIs: [],\n  methodIDs: {}\n};\n\nfunction _getABIs() {\n  return state.savedABIs;\n}\n\nfunction _addABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function (abi) {\n      if (abi.name) {\n        const signature = sha3(abi.name + \"(\" + abi.inputs.map(function (input) {\n          return input.type;\n        }).join(\",\") + \")\");\n\n        if (abi.type === \"event\") {\n          state.methodIDs[signature.slice(2)] = abi;\n        } else {\n          state.methodIDs[signature.slice(2, 10)] = abi;\n        }\n      }\n    });\n    state.savedABIs = state.savedABIs.concat(abiArray);\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _removeABI(abiArray) {\n  if (Array.isArray(abiArray)) {\n    // Iterate new abi to generate method id\"s\n    abiArray.map(function (abi) {\n      if (abi.name) {\n        const signature = sha3(abi.name + \"(\" + abi.inputs.map(function (input) {\n          return input.type;\n        }).join(\",\") + \")\");\n\n        if (abi.type === \"event\") {\n          if (state.methodIDs[signature.slice(2)]) {\n            delete state.methodIDs[signature.slice(2)];\n          }\n        } else {\n          if (state.methodIDs[signature.slice(2, 10)]) {\n            delete state.methodIDs[signature.slice(2, 10)];\n          }\n        }\n      }\n    });\n  } else {\n    throw new Error(\"Expected ABI array, got \" + typeof abiArray);\n  }\n}\n\nfunction _getMethodIDs() {\n  return state.methodIDs;\n}\n\nfunction _decodeMethod(data) {\n  const methodID = data.slice(2, 10);\n  const abiItem = state.methodIDs[methodID];\n\n  if (abiItem) {\n    const params = abiItem.inputs.map(function (item) {\n      return item.type;\n    });\n    let decoded = abiCoder.decodeParameters(params, data.slice(10));\n    let retData = {\n      name: abiItem.name,\n      params: []\n    };\n\n    for (let i = 0; i < decoded.__length__; i++) {\n      let param = decoded[i];\n      let parsedParam = param;\n      const isUint = abiItem.inputs[i].type.indexOf(\"uint\") === 0;\n      const isInt = abiItem.inputs[i].type.indexOf(\"int\") === 0;\n      const isAddress = abiItem.inputs[i].type.indexOf(\"address\") === 0;\n\n      if (isUint || isInt) {\n        const isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(val => new BN(val).toString());\n        } else {\n          parsedParam = new BN(param).toString();\n        }\n      } // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all\n\n\n      if (isAddress) {\n        const isArray = Array.isArray(param);\n\n        if (isArray) {\n          parsedParam = param.map(_ => _.toLowerCase());\n        } else {\n          parsedParam = param.toLowerCase();\n        }\n      }\n\n      retData.params.push({\n        name: abiItem.inputs[i].name,\n        value: parsedParam,\n        type: abiItem.inputs[i].type\n      });\n    }\n\n    return retData;\n  }\n}\n\nfunction _decodeLogs(logs) {\n  return logs.filter(log => log.topics.length > 0).map(logItem => {\n    const methodID = logItem.topics[0].slice(2);\n    const method = state.methodIDs[methodID];\n\n    if (method) {\n      const logData = logItem.data;\n      let decodedParams = [];\n      let dataIndex = 0;\n      let topicsIndex = 1;\n      let dataTypes = [];\n      method.inputs.map(function (input) {\n        if (!input.indexed) {\n          dataTypes.push(input.type);\n        }\n      });\n      const decodedData = abiCoder.decodeParameters(dataTypes, logData.slice(2)); // Loop topic and data to get the params\n\n      method.inputs.map(function (param) {\n        let decodedP = {\n          name: param.name,\n          type: param.type\n        };\n\n        if (param.indexed) {\n          decodedP.value = logItem.topics[topicsIndex];\n          topicsIndex++;\n        } else {\n          decodedP.value = decodedData[dataIndex];\n          dataIndex++;\n        }\n\n        if (param.type === \"address\") {\n          decodedP.value = decodedP.value.toLowerCase(); // 42 because len(0x) + 40\n\n          if (decodedP.value.length > 42) {\n            let toRemove = decodedP.value.length - 42;\n            let temp = decodedP.value.split(\"\");\n            temp.splice(2, toRemove);\n            decodedP.value = temp.join(\"\");\n          }\n        }\n\n        if (param.type === \"uint256\" || param.type === \"uint8\" || param.type === \"int\") {\n          // ensure to remove leading 0x for hex numbers\n          if (typeof decodedP.value === \"string\" && decodedP.value.startsWith(\"0x\")) {\n            decodedP.value = new BN(decodedP.value.slice(2), 16).toString(10);\n          } else {\n            decodedP.value = new BN(decodedP.value).toString(10);\n          }\n        }\n\n        decodedParams.push(decodedP);\n      });\n      return {\n        name: method.name,\n        events: decodedParams,\n        address: logItem.address\n      };\n    }\n  });\n}\n\nmodule.exports = {\n  getABIs: _getABIs,\n  addABI: _addABI,\n  getMethodIDs: _getMethodIDs,\n  decodeMethod: _decodeMethod,\n  decodeLogs: _decodeLogs,\n  removeABI: _removeABI\n};","map":null,"metadata":{},"sourceType":"script"}
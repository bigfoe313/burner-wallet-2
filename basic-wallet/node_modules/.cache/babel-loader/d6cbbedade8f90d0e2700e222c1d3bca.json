{"ast":null,"code":"var _slicedToArray = require(\"/home/aforbers/burner-wallet-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst _require = require('web3-utils'),\n      fromWei = _require.fromWei,\n      toWei = _require.toWei,\n      toBN = _require.toBN;\n\nconst pricefeed = require('./pricefeed');\n\nconst _require2 = require('./utils/decimals'),\n      toDecimal = _require2.toDecimal;\n\nconst PRICE_POLL_INTERVAL = 15 * 1000;\n\nclass Asset {\n  constructor({\n    id,\n    name,\n    network,\n    usdPrice,\n    priceSymbol,\n    icon = null,\n    type = null,\n    decimals = 18\n  }) {\n    this.id = id;\n    this.name = name;\n    this.network = network;\n    this.usdPrice = usdPrice;\n    this.priceSymbol = priceSymbol;\n    this.type = type;\n    this.icon = icon;\n    this.decimals = decimals;\n    this.cleanupFunctions = [];\n  }\n\n  setCore(core) {\n    this.core = core;\n  }\n\n  supportsMessages() {\n    return false;\n  }\n\n  async getTx(txHash) {\n    throw new Error('Not implemented');\n  }\n\n  getDisplayValue(value, decimals = 2) {\n    const displayVal = toDecimal(value.toString(), this.decimals);\n\n    if (displayVal.indexOf('.') !== -1) {\n      return displayVal.substr(0, displayVal.indexOf('.') + decimals + 1);\n    }\n\n    return displayVal;\n  }\n\n  getUSDValue(value, decimals = 2) {\n    if (this.usdPrice) {\n      return (+this.getDisplayValue(value, 10) * this.usdPrice).toFixed(decimals);\n    }\n\n    throw new Error('USD price not available');\n  }\n\n  async getBalance(account) {\n    throw new Error('getBalance not implemented');\n  }\n\n  async getDisplayBalance(account, decimals = 2) {\n    const balance = await this.getBalance(account);\n    return this.getDisplayValue(balance, decimals);\n  }\n\n  async getUSDBalance(account, decimals = 2) {\n    const balance = await this.getBalance(account);\n    return this.getUSDValue(balance, decimals);\n  }\n\n  startWatchingAddress(address) {\n    throw new Error('watching not implemented');\n  }\n\n  async send(params) {\n    if (params.ether) {\n      params.value = toWei(params.ether, 'ether');\n      delete params.ether;\n    }\n\n    const response = await this._send(params);\n    this.core.addHistoryEvent({\n      id: response.id,\n      asset: this.id,\n      type: 'send',\n      value: params.value,\n      from: params.from,\n      to: params.to,\n      tx: response.txHash,\n      // Chose between this and transactionshash\n      message: params.message || null,\n      timestamp: Math.floor(Date.now() / 1000)\n    });\n    return response;\n  }\n\n  async getMaximumSendableBalance(address, recipient = '0x1111111111111111111111111111111111111111') {\n    const _ref = await Promise.all([this.getBalance(address), this.getSendFee(address, recipient)]),\n          _ref2 = _slicedToArray(_ref, 2),\n          balance = _ref2[0],\n          sendFee = _ref2[1];\n\n    const maximum = toBN(balance).sub(toBN(sendFee)).toString();\n\n    if (maximum.charAt(0) === '-') {\n      return '0';\n    }\n\n    return maximum;\n  }\n\n  async getSendFee() {\n    return '0';\n  }\n\n  async getGrowthRate() {\n    return '0';\n  }\n\n  async _send({\n    from,\n    to,\n    value\n  }) {\n    throw new Error('send not implemented');\n  }\n\n  async _startPricePolling() {\n    const interval = setInterval(async () => {\n      this.usdPrice = await pricefeed.getPrice(this.priceSymbol);\n    }, PRICE_POLL_INTERVAL);\n    this.cleanupFunctions.push(() => clearInterval(interval));\n    this.usdPrice = await pricefeed.getPrice(this.priceSymbol);\n  }\n\n  getWeb3(options) {\n    return this.core.getWeb3(this.network, options);\n  }\n\n  async _getBlockTimestamp(blockNum) {\n    const block = await this.getWeb3().eth.getBlock(blockNum);\n    return block.timestamp;\n  }\n\n  start() {\n    if (this.priceSymbol) {\n      this._startPricePolling();\n    }\n  }\n\n  stop() {\n    this.cleanupFunctions.forEach(fn => fn());\n  }\n\n  poll(callback, interval) {\n    let running = true;\n\n    const loop = async () => {\n      if (!running) {\n        return;\n      }\n\n      try {\n        await callback();\n      } catch (e) {\n        console.warn('Error in loop', e);\n      }\n\n      setTimeout(loop, interval);\n    };\n\n    loop();\n\n    const unsubscribe = () => {\n      running = false;\n    };\n\n    this.cleanupFunctions.push(unsubscribe);\n    return unsubscribe;\n  }\n\n}\n\nmodule.exports = Asset;","map":null,"metadata":{},"sourceType":"script"}